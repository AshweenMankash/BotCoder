"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botframework_connector_1 = require("botframework-connector");
const botbuilder_core_1 = require("botbuilder-core");
/** @private */
class TraceActivity {
    static makeCommandActivity(command) {
        return {
            type: botbuilder_core_1.ActivityTypes.Trace,
            timestamp: new Date(),
            name: 'Command',
            label: 'Command',
            value: command,
            valueType: 'https://www.botframework.com/schemas/command'
        };
    }
    static fromActivity(activity, name, label) {
        return {
            type: botbuilder_core_1.ActivityTypes.Trace,
            timestamp: new Date(),
            name: name,
            label: label,
            value: activity,
            valueType: 'https://www.botframework.com/schemas/activity'
        };
    }
    static fromState(botState) {
        return {
            type: botbuilder_core_1.ActivityTypes.Trace,
            timestamp: new Date(),
            name: 'BotState',
            label: 'Bot State',
            value: botState,
            valueType: 'https://www.botframework.com/schemas/botState'
        };
    }
    static fromConversationReference(conversationReference) {
        return {
            type: botbuilder_core_1.ActivityTypes.Trace,
            timestamp: new Date(),
            name: 'Deleted Message',
            label: 'MessageDelete',
            value: conversationReference,
            valueType: 'https://www.botframework.com/schemas/conversationReference'
        };
    }
    static fromError(errorMessage) {
        return {
            type: botbuilder_core_1.ActivityTypes.Trace,
            timestamp: new Date(),
            name: 'Turn Error',
            label: 'TurnError',
            value: errorMessage,
            valueType: 'https://www.botframework.com/schemas/error'
        };
    }
}
/** @private */
class InterceptionMiddleware {
    /** Implement middleware signature
     * @param context {TurnContext} An incoming TurnContext object.
     * @param next {function} The next delegate function.
     */
    async onTurn(turnContext, next) {
        var { shouldForwardToApplication, shouldIntercept } = await this.invokeInbound(turnContext, TraceActivity.fromActivity(turnContext.activity, 'ReceivedActivity', 'Received Activity'));
        if (shouldIntercept) {
            turnContext.onSendActivities(async (ctx, activities, nextSend) => {
                var traceActivities = [];
                activities.forEach(activity => {
                    traceActivities.push(TraceActivity.fromActivity(activity, 'SentActivity', 'Sent Activity'));
                });
                await this.invokeOutbound(ctx, traceActivities);
                return await nextSend();
            });
            turnContext.onUpdateActivity(async (ctx, activity, nextUpdate) => {
                var traceActivity = TraceActivity.fromActivity(activity, 'MessageUpdate', 'Updated Message');
                await this.invokeOutbound(ctx, [traceActivity]);
                return await nextUpdate();
            });
            turnContext.onDeleteActivity(async (ctx, reference, nextDelete) => {
                var traceActivity = TraceActivity.fromConversationReference(reference);
                await this.invokeOutbound(ctx, [traceActivity]);
                return await nextDelete();
            });
        }
        if (shouldForwardToApplication) {
            try {
                await next();
            }
            catch (err) {
                var traceActivity = TraceActivity.fromError(err.toString());
                await this.invokeOutbound(turnContext, [traceActivity]);
                throw err;
            }
        }
        if (shouldIntercept) {
            await this.invokeTraceState(turnContext);
        }
    }
    async invokeInbound(turnContext, traceActivity) {
        try {
            return await this.inbound(turnContext, traceActivity);
        }
        catch (err) {
            console.warn(`Exception in inbound interception ${err}`);
            return { shouldForwardToApplication: true, shouldIntercept: false };
        }
    }
    async invokeOutbound(turnContext, traceActivities) {
        try {
            await this.outbound(turnContext, traceActivities);
        }
        catch (err) {
            console.warn(`Exception in outbound interception ${err}`);
        }
    }
    async invokeTraceState(turnContext) {
        try {
            await this.traceState(turnContext);
        }
        catch (err) {
            console.warn(`Exception in state interception ${err}`);
        }
    }
}
/**
 * InspectionMiddleware for emulator inspection of runtime Activities and BotState.
 *
 * @remarks
 * InspectionMiddleware for emulator inspection of runtime Activities and BotState.
 *
 */
class InspectionMiddleware extends InterceptionMiddleware {
    /**
     * Create the Inspection middleware for sending trace activities out to an emulator session
     */
    constructor(inspectionState, userState, conversationState, credentials) {
        super();
        this.inspectionState = inspectionState;
        this.inspectionStateAccessor = inspectionState.createProperty('InspectionSessionByStatus');
        this.userState = userState;
        this.conversationState = conversationState;
        credentials = { appId: '', appPassword: '', ...credentials };
        this.credentials = new botframework_connector_1.MicrosoftAppCredentials(credentials.appId, credentials.appPassword);
    }
    async processCommand(turnContext) {
        if (turnContext.activity.type == botbuilder_core_1.ActivityTypes.Message && turnContext.activity.text !== undefined) {
            var originalText = turnContext.activity.text;
            botbuilder_core_1.TurnContext.removeRecipientMention(turnContext.activity);
            var command = turnContext.activity.text.trim().split(' ');
            if (command.length > 1 && command[0] === InspectionMiddleware.command) {
                if (command.length === 2 && command[1] === 'open') {
                    await this.processOpenCommand(turnContext);
                    return true;
                }
                if (command.length === 3 && command[1] === 'attach') {
                    await this.processAttachCommand(turnContext, command[2]);
                    return true;
                }
            }
            turnContext.activity.text = originalText;
        }
        return false;
    }
    async inbound(turnContext, traceActivity) {
        if (await this.processCommand(turnContext)) {
            return { shouldForwardToApplication: false, shouldIntercept: false };
        }
        var session = await this.findSession(turnContext);
        if (session !== undefined) {
            if (await this.invokeSend(turnContext, session, traceActivity)) {
                return { shouldForwardToApplication: true, shouldIntercept: true };
            }
            else {
                return { shouldForwardToApplication: true, shouldIntercept: false };
            }
        }
        else {
            return { shouldForwardToApplication: true, shouldIntercept: false };
        }
    }
    async outbound(turnContext, traceActivities) {
        var session = await this.findSession(turnContext);
        if (session !== undefined) {
            for (var i = 0; i < traceActivities.length; i++) {
                var traceActivity = traceActivities[i];
                if (!await this.invokeSend(turnContext, session, traceActivity)) {
                    break;
                }
            }
        }
    }
    async traceState(turnContext) {
        var session = await this.findSession(turnContext);
        if (session !== undefined) {
            if (this.userState !== undefined) {
                await this.userState.load(turnContext, false);
            }
            if (this.conversationState != undefined) {
                await this.conversationState.load(turnContext, false);
            }
            var botState = {};
            if (this.userState !== undefined) {
                botState.userState = this.userState.get(turnContext);
            }
            if (this.conversationState !== undefined) {
                botState.conversationState = this.conversationState.get(turnContext);
            }
            await this.invokeSend(turnContext, session, TraceActivity.fromState(botState));
        }
    }
    async processOpenCommand(turnContext) {
        var sessions = await this.inspectionStateAccessor.get(turnContext, InspectionSessionsByStatus.DefaultValue);
        var sessionId = this.openCommand(sessions, botbuilder_core_1.TurnContext.getConversationReference(turnContext.activity));
        await turnContext.sendActivity(TraceActivity.makeCommandActivity(`${InspectionMiddleware.command} attach ${sessionId}`));
        await this.inspectionState.saveChanges(turnContext, false);
    }
    async processAttachCommand(turnContext, sessionId) {
        var sessions = await this.inspectionStateAccessor.get(turnContext, InspectionSessionsByStatus.DefaultValue);
        if (this.attachComamnd(turnContext.activity.conversation.id, sessions, sessionId)) {
            await turnContext.sendActivity('Attached to session, all traffic is being replicated for inspection.');
        }
        else {
            await turnContext.sendActivity(`Open session with id ${sessionId} does not exist.`);
        }
        await this.inspectionState.saveChanges(turnContext, false);
    }
    openCommand(sessions, conversationReference) {
        function generate_guid() {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                s4() + '-' + s4() + s4() + s4();
        }
        var sessionId = generate_guid();
        sessions.openedSessions[sessionId] = conversationReference;
        return sessionId;
    }
    attachComamnd(conversationId, sessions, sessionId) {
        var inspectionSessionState = sessions.openedSessions[sessionId];
        if (inspectionSessionState !== undefined) {
            sessions.attachedSessions[conversationId] = inspectionSessionState;
            delete sessions.openedSessions[sessionId];
            return true;
        }
        return false;
    }
    async findSession(turnContext) {
        var sessions = await this.inspectionStateAccessor.get(turnContext, InspectionSessionsByStatus.DefaultValue);
        var conversationReference = sessions.attachedSessions[turnContext.activity.conversation.id];
        if (conversationReference !== undefined) {
            return new InspectionSession(conversationReference, this.credentials);
        }
        return undefined;
    }
    async invokeSend(turnContext, session, activity) {
        if (await session.send(activity)) {
            return true;
        }
        else {
            await this.cleanUpSession(turnContext);
            return false;
        }
    }
    async cleanUpSession(turnContext) {
        var sessions = await this.inspectionStateAccessor.get(turnContext, InspectionSessionsByStatus.DefaultValue);
        delete sessions.attachedSessions[turnContext.activity.conversation.id];
        await this.inspectionState.saveChanges(turnContext, false);
    }
}
InspectionMiddleware.command = "/INSPECT";
exports.InspectionMiddleware = InspectionMiddleware;
/** @private */
class InspectionSession {
    constructor(conversationReference, credentials) {
        this.conversationReference = conversationReference;
        this.connectorClient = new botframework_connector_1.ConnectorClient(credentials, { baseUri: conversationReference.serviceUrl });
    }
    async send(activity) {
        botbuilder_core_1.TurnContext.applyConversationReference(activity, this.conversationReference);
        try {
            await this.connectorClient.conversations.sendToConversation(activity.conversation.id, activity);
        }
        catch (err) {
            return false;
        }
        return true;
    }
}
/** @private */
class InspectionSessionsByStatus {
    constructor() {
        this.openedSessions = {};
        this.attachedSessions = {};
    }
}
InspectionSessionsByStatus.DefaultValue = new InspectionSessionsByStatus();
/**
 * InspectionState for use by the InspectionMiddleware for emulator inspection of runtime Activities and BotState.
 *
 * @remarks
 * InspectionState for use by the InspectionMiddleware for emulator inspection of runtime Activities and BotState.
 *
 */
class InspectionState extends botbuilder_core_1.BotState {
    constructor(storage) {
        super(storage, (context) => {
            return Promise.resolve(this.getStorageKey(context));
        });
    }
    getStorageKey(turnContext) {
        return 'InspectionState';
    }
}
exports.InspectionState = InspectionState;
//# sourceMappingURL=inspectionMiddleware.js.map